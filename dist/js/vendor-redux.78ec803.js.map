{"version":3,"sources":["webpack:///js/vendor-redux.78ec803.js","webpack:///./node_modules/redux-promise-middleware/dist/es/isPromise.js","webpack:///./node_modules/redux-promise-middleware/dist/es/index.js","webpack:///./node_modules/redux-thunk/es/index.js"],"names":["webpackJsonp","1","module","exports","__webpack_require__","8x3u","isPromise","value","_typeof","then","Object","defineProperty","_typeof2","Symbol","iterator","obj","constructor","prototype","default","S2k5","promiseMiddleware","config","arguments","length","undefined","PROMISE_TYPE_SUFFIXES","promiseTypeSuffixes","defaultTypes","PROMISE_TYPE_DELIMITER","promiseTypeDelimiter","ref","dispatch","next","action","promise","data","payload","PAYLOAD","_isPromise2","_extends","TYPE","type","META","meta","_PROMISE_TYPE_SUFFIXE","_slicedToArray","_PENDING","_FULFILLED","_REJECTED","getAction","newPayload","isRejected","join","error","handleReject","reason","rejectedAction","handleFulfill","resolvedAction","REJECTED","FULFILLED","PENDING","_isPromise","__esModule","sliceIterator","arr","i","_arr","_n","_d","_e","_s","_i","done","push","err","Array","isArray","TypeError","assign","target","source","key","hasOwnProperty","call","bEzl","createThunkMiddleware","extraArgument","_ref","getState","thunk","withExtraArgument"],"mappings":"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","file":"js/vendor-redux.78ec803.js","sourcesContent":["webpackJsonp([3],{\n\n/***/ 1:\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(\"Ol7m\");\n__webpack_require__(\"S2k5\");\nmodule.exports = __webpack_require__(\"bEzl\");\n\n\n/***/ }),\n\n/***/ \"8x3u\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof2 = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.default = isPromise;\nvar _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n  return typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n};\n\nfunction isPromise(value) {\n  if (value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\n    return value && typeof value.then === 'function';\n  }\n\n  return false;\n}\n\n/***/ }),\n\n/***/ \"S2k5\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.REJECTED = exports.FULFILLED = exports.PENDING = undefined;\nexports.default = promiseMiddleware;\n\nvar _isPromise = __webpack_require__(\"8x3u\");\n\nvar _isPromise2 = _interopRequireDefault(_isPromise);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];var _n = true;var _d = false;var _e = undefined;try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;_e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }return _arr;\n  }return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }return target;\n};\n\n/**\n * Note to contributors: Please also remember to check and make sure\n * that `index.d.ts` is also up to date with the implementation when\n * you add new features or modify existing ones.\n */\n\n// The default async action types\nvar PENDING = exports.PENDING = 'PENDING';\nvar FULFILLED = exports.FULFILLED = 'FULFILLED';\nvar REJECTED = exports.REJECTED = 'REJECTED';\nvar defaultTypes = [PENDING, FULFILLED, REJECTED];\n\n/**\n * Function: promiseMiddleware\n * Description: The main promiseMiddleware accepts a configuration\n * object and returns the middleware.\n */\nfunction promiseMiddleware() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var PROMISE_TYPE_SUFFIXES = config.promiseTypeSuffixes || defaultTypes;\n  var PROMISE_TYPE_DELIMITER = config.promiseTypeDelimiter || '_';\n\n  return function (ref) {\n    var dispatch = ref.dispatch;\n\n    return function (next) {\n      return function (action) {\n\n        /**\n         * Instantiate variables to hold:\n         * (1) the promise\n         * (2) the data for optimistic updates\n         */\n        var promise = void 0;\n        var data = void 0;\n\n        /**\n         * There are multiple ways to dispatch a promise. The first step is to\n         * determine if the promise is defined:\n         * (a) explicitly (action.payload.promise is the promise)\n         * (b) implicitly (action.payload is the promise)\n         * (c) as an async function (returns a promise when called)\n         *\n         * If the promise is not defined in one of these three ways, we don't do\n         * anything and move on to the next middleware in the middleware chain.\n         */\n\n        // Step 1a: Is there a payload?\n        if (action.payload) {\n          var PAYLOAD = action.payload;\n\n          // Step 1.1: Is the promise implicitly defined?\n          if ((0, _isPromise2.default)(PAYLOAD)) {\n            promise = PAYLOAD;\n          }\n\n          // Step 1.2: Is the promise explicitly defined?\n          else if ((0, _isPromise2.default)(PAYLOAD.promise)) {\n              promise = PAYLOAD.promise;\n              data = PAYLOAD.data;\n            }\n\n            // Step 1.3: Is the promise returned by an async function?\n            else if (typeof PAYLOAD === 'function' || typeof PAYLOAD.promise === 'function') {\n                promise = PAYLOAD.promise ? PAYLOAD.promise() : PAYLOAD();\n                data = PAYLOAD.promise ? PAYLOAD.data : undefined;\n\n                // Step 1.3.1: Is the return of action.payload a promise?\n                if (!(0, _isPromise2.default)(promise)) {\n\n                  // If not, move on to the next middleware.\n                  return next(_extends({}, action, {\n                    payload: promise\n                  }));\n                }\n              }\n\n              // Step 1.4: If there's no promise, move on to the next middleware.\n              else {\n                  return next(action);\n                }\n\n          // Step 1b: If there's no payload, move on to the next middleware.\n        } else {\n          return next(action);\n        }\n\n        /**\n         * Instantiate and define constants for:\n         * (1) the action type\n         * (2) the action meta\n         */\n        var TYPE = action.type;\n        var META = action.meta;\n\n        /**\n         * Instantiate and define constants for the action type suffixes.\n         * These are appended to the end of the action type.\n         */\n\n        var _PROMISE_TYPE_SUFFIXE = _slicedToArray(PROMISE_TYPE_SUFFIXES, 3),\n            _PENDING = _PROMISE_TYPE_SUFFIXE[0],\n            _FULFILLED = _PROMISE_TYPE_SUFFIXE[1],\n            _REJECTED = _PROMISE_TYPE_SUFFIXE[2];\n\n        /**\n         * Function: getAction\n         * Description: This function constructs and returns a rejected\n         * or fulfilled action object. The action object is based off the Flux\n         * Standard Action (FSA).\n         *\n         * Given an original action with the type FOO:\n         *\n         * The rejected object model will be:\n         * {\n         *   error: true,\n         *   type: 'FOO_REJECTED',\n         *   payload: ...,\n         *   meta: ... (optional)\n         * }\n         *\n         * The fulfilled object model will be:\n         * {\n         *   type: 'FOO_FULFILLED',\n         *   payload: ...,\n         *   meta: ... (optional)\n         * }\n         */\n\n        var getAction = function getAction(newPayload, isRejected) {\n          return _extends({\n            // Concatentate the type string property.\n            type: [TYPE, isRejected ? _REJECTED : _FULFILLED].join(PROMISE_TYPE_DELIMITER)\n\n          }, newPayload === null || typeof newPayload === 'undefined' ? {} : {\n            payload: newPayload\n          }, META !== undefined ? { meta: META } : {}, isRejected ? {\n            error: true\n          } : {});\n        };\n\n        /**\n         * Function: handleReject\n         * Calls: getAction to construct the rejected action\n         * Description: This function dispatches the rejected action and returns\n         * the original Error object. Please note the developer is responsible\n         * for constructing and throwing an Error object. The middleware does not\n         * construct any Errors.\n         */\n        var handleReject = function handleReject(reason) {\n          var rejectedAction = getAction(reason, true);\n          dispatch(rejectedAction);\n\n          throw reason;\n        };\n\n        /**\n         * Function: handleFulfill\n         * Calls: getAction to construct the fullfilled action\n         * Description: This function dispatches the fulfilled action and\n         * returns the success object. The success object should\n         * contain the value and the dispatched action.\n         */\n        var handleFulfill = function handleFulfill() {\n          var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n          var resolvedAction = getAction(value, false);\n          dispatch(resolvedAction);\n\n          return { value: value, action: resolvedAction };\n        };\n\n        /**\n         * First, dispatch the pending action:\n         * This object describes the pending state of a promise and will include\n         * any data (for optimistic updates) and/or meta from the original action.\n         */\n        next(_extends({\n          // Concatentate the type string.\n          type: [TYPE, _PENDING].join(PROMISE_TYPE_DELIMITER)\n\n        }, data !== undefined ? { payload: data } : {}, META !== undefined ? { meta: META } : {}));\n\n        /**\n         * Second, dispatch a rejected or fulfilled action and move on to the\n         * next middleware.\n         */\n        return promise.then(handleFulfill, handleReject);\n      };\n    };\n  };\n}\n\n/***/ }),\n\n/***/ \"bEzl\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nfunction createThunkMiddleware(extraArgument) {\n  return function (_ref) {\n    var dispatch = _ref.dispatch,\n        getState = _ref.getState;\n    return function (next) {\n      return function (action) {\n        if (typeof action === 'function') {\n          return action(dispatch, getState, extraArgument);\n        }\n\n        return next(action);\n      };\n    };\n  };\n}\n\nvar thunk = createThunkMiddleware();\nthunk.withExtraArgument = createThunkMiddleware;\n\nexports.default = thunk;\n\n/***/ })\n\n},[1]);\n\n\n// WEBPACK FOOTER //\n// js/vendor-redux.78ec803.js","var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexport default function isPromise(value) {\n  if (value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\n    return value && typeof value.then === 'function';\n  }\n\n  return false;\n}\n\n\n// WEBPACK FOOTER //\n// ./node_modules/redux-promise-middleware/dist/es/isPromise.js","var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nimport isPromise from './isPromise.js';\n\n/**\n * Note to contributors: Please also remember to check and make sure\n * that `index.d.ts` is also up to date with the implementation when\n * you add new features or modify existing ones.\n */\n\n// The default async action types\nexport var PENDING = 'PENDING';\nexport var FULFILLED = 'FULFILLED';\nexport var REJECTED = 'REJECTED';\nvar defaultTypes = [PENDING, FULFILLED, REJECTED];\n\n/**\n * Function: promiseMiddleware\n * Description: The main promiseMiddleware accepts a configuration\n * object and returns the middleware.\n */\nexport default function promiseMiddleware() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var PROMISE_TYPE_SUFFIXES = config.promiseTypeSuffixes || defaultTypes;\n  var PROMISE_TYPE_DELIMITER = config.promiseTypeDelimiter || '_';\n\n  return function (ref) {\n    var dispatch = ref.dispatch;\n\n\n    return function (next) {\n      return function (action) {\n\n        /**\n         * Instantiate variables to hold:\n         * (1) the promise\n         * (2) the data for optimistic updates\n         */\n        var promise = void 0;\n        var data = void 0;\n\n        /**\n         * There are multiple ways to dispatch a promise. The first step is to\n         * determine if the promise is defined:\n         * (a) explicitly (action.payload.promise is the promise)\n         * (b) implicitly (action.payload is the promise)\n         * (c) as an async function (returns a promise when called)\n         *\n         * If the promise is not defined in one of these three ways, we don't do\n         * anything and move on to the next middleware in the middleware chain.\n         */\n\n        // Step 1a: Is there a payload?\n        if (action.payload) {\n          var PAYLOAD = action.payload;\n\n          // Step 1.1: Is the promise implicitly defined?\n          if (isPromise(PAYLOAD)) {\n            promise = PAYLOAD;\n          }\n\n          // Step 1.2: Is the promise explicitly defined?\n          else if (isPromise(PAYLOAD.promise)) {\n              promise = PAYLOAD.promise;\n              data = PAYLOAD.data;\n            }\n\n            // Step 1.3: Is the promise returned by an async function?\n            else if (typeof PAYLOAD === 'function' || typeof PAYLOAD.promise === 'function') {\n                promise = PAYLOAD.promise ? PAYLOAD.promise() : PAYLOAD();\n                data = PAYLOAD.promise ? PAYLOAD.data : undefined;\n\n                // Step 1.3.1: Is the return of action.payload a promise?\n                if (!isPromise(promise)) {\n\n                  // If not, move on to the next middleware.\n                  return next(_extends({}, action, {\n                    payload: promise\n                  }));\n                }\n              }\n\n              // Step 1.4: If there's no promise, move on to the next middleware.\n              else {\n                  return next(action);\n                }\n\n          // Step 1b: If there's no payload, move on to the next middleware.\n        } else {\n          return next(action);\n        }\n\n        /**\n         * Instantiate and define constants for:\n         * (1) the action type\n         * (2) the action meta\n         */\n        var TYPE = action.type;\n        var META = action.meta;\n\n        /**\n         * Instantiate and define constants for the action type suffixes.\n         * These are appended to the end of the action type.\n         */\n\n        var _PROMISE_TYPE_SUFFIXE = _slicedToArray(PROMISE_TYPE_SUFFIXES, 3),\n            _PENDING = _PROMISE_TYPE_SUFFIXE[0],\n            _FULFILLED = _PROMISE_TYPE_SUFFIXE[1],\n            _REJECTED = _PROMISE_TYPE_SUFFIXE[2];\n\n        /**\n         * Function: getAction\n         * Description: This function constructs and returns a rejected\n         * or fulfilled action object. The action object is based off the Flux\n         * Standard Action (FSA).\n         *\n         * Given an original action with the type FOO:\n         *\n         * The rejected object model will be:\n         * {\n         *   error: true,\n         *   type: 'FOO_REJECTED',\n         *   payload: ...,\n         *   meta: ... (optional)\n         * }\n         *\n         * The fulfilled object model will be:\n         * {\n         *   type: 'FOO_FULFILLED',\n         *   payload: ...,\n         *   meta: ... (optional)\n         * }\n         */\n\n\n        var getAction = function getAction(newPayload, isRejected) {\n          return _extends({\n            // Concatentate the type string property.\n            type: [TYPE, isRejected ? _REJECTED : _FULFILLED].join(PROMISE_TYPE_DELIMITER)\n\n          }, newPayload === null || typeof newPayload === 'undefined' ? {} : {\n            payload: newPayload\n          }, META !== undefined ? { meta: META } : {}, isRejected ? {\n            error: true\n          } : {});\n        };\n\n        /**\n         * Function: handleReject\n         * Calls: getAction to construct the rejected action\n         * Description: This function dispatches the rejected action and returns\n         * the original Error object. Please note the developer is responsible\n         * for constructing and throwing an Error object. The middleware does not\n         * construct any Errors.\n         */\n        var handleReject = function handleReject(reason) {\n          var rejectedAction = getAction(reason, true);\n          dispatch(rejectedAction);\n\n          throw reason;\n        };\n\n        /**\n         * Function: handleFulfill\n         * Calls: getAction to construct the fullfilled action\n         * Description: This function dispatches the fulfilled action and\n         * returns the success object. The success object should\n         * contain the value and the dispatched action.\n         */\n        var handleFulfill = function handleFulfill() {\n          var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n          var resolvedAction = getAction(value, false);\n          dispatch(resolvedAction);\n\n          return { value: value, action: resolvedAction };\n        };\n\n        /**\n         * First, dispatch the pending action:\n         * This object describes the pending state of a promise and will include\n         * any data (for optimistic updates) and/or meta from the original action.\n         */\n        next(_extends({\n          // Concatentate the type string.\n          type: [TYPE, _PENDING].join(PROMISE_TYPE_DELIMITER)\n\n        }, data !== undefined ? { payload: data } : {}, META !== undefined ? { meta: META } : {}));\n\n        /**\n         * Second, dispatch a rejected or fulfilled action and move on to the\n         * next middleware.\n         */\n        return promise.then(handleFulfill, handleReject);\n      };\n    };\n  };\n}\n\n\n// WEBPACK FOOTER //\n// ./node_modules/redux-promise-middleware/dist/es/index.js","function createThunkMiddleware(extraArgument) {\n  return function (_ref) {\n    var dispatch = _ref.dispatch,\n        getState = _ref.getState;\n    return function (next) {\n      return function (action) {\n        if (typeof action === 'function') {\n          return action(dispatch, getState, extraArgument);\n        }\n\n        return next(action);\n      };\n    };\n  };\n}\n\nvar thunk = createThunkMiddleware();\nthunk.withExtraArgument = createThunkMiddleware;\n\nexport default thunk;\n\n\n// WEBPACK FOOTER //\n// ./node_modules/redux-thunk/es/index.js"],"sourceRoot":""}